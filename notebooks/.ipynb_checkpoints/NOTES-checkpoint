conda activate jnb
jupyter-lab

conda install -c conda-forge jupyterlab-spellchecker
conda install -c conda-forge scipy

2022-09-01 
BAK/EMCNB_2022-08-31_Good.tar.gz
1. I decided to capitalize only the user variables. This will make the code easier for user to follow and the parameters that user has to update more obvious. Partially done, should make changes when I see a variable.
2. I am trying to keep the code segments that user sees to a minimum. I have created a few functions in the utils file that allows me to do that. 


2022-08-31 After a problem, I was able to recover and the current version that also is saved as ../BAK/EMCNB_2022-08-31_Good.tar.gz is in very good shape. I removed the arbitrary x-section since the ratios where not coming out right. If I figure out how it is maping, I may be able to re use it. For now, I use simple xsections. Try to finish before adding more. List below is what I think may be needed
2022-08-31 Notebook is in very good shape and I am able to make horizontal, vertical and profile plots and save the files. 
Items to look into:
- Can I plot arbitrary cross section (I added a sample that requires work and is based on https://stackoverflow.com/questions/58706834/angled-slice-in-xarray. Compared to the EMC plot for the same path, looks reasonable
- Based on the color level I have used for the generalized cross section above, do I need to do the same for other plots?
- Can I display 3D plots
- Can I avoid using netCDF4 and create geoCSV from Xarray dataset?
This version is saved in BAK/EMCNB_2022-08-31.tar.gz

Although I was able to obtain an approximate cross section with code below, but doing this in geographic coordinate system produces lots of errors. Unless I am able to conver my geographic coordinates to a linear one, x-section does not work.

def llz2xyz(lat, lon, depth):
    """ convert latitude, longitude, and altitude to earth-centered, earth-fixed (ECEF) cartesian
    the output coordinates will be normalized to the radius of interest for the
    displayed sphere as defined by the rad parameter above

    code is based on:

    http://www.mathworks.com/matlabcentral/fileexchange/7942-covert-lat--lon--alt-to-ecef-cartesian/content/lla2ecef.m
    latitude, longitude, altitude to ECEF ("Earth-Centered, Earth-Fixed")
    http://www.gmat.unsw.edu.au/snap/gps/clynch_pdfs/coordcvt.pdf

    calculations based on:

    http://rbrundritt.wordpress.com/2008/10/14/conversion-between-spherical-and-cartesian-coordinates-systems/
    http://stackoverflow.com/questions/10473852/convert-latitude-and-longitude-to-point-in-3d-space
    http://www.oosa.unvienna.org/pdf/icg/2012/template/WGS_84.pdf

    computation verified using:

    http://www.sysense.com/products/ecef_lla_converter/index.html

    Keyword arguments:
    lat: latitude (deg)
    lon: longitude (deg)
    depth: depth (km)

    Return values:
    x: x-coordinate  normalized to the radius of Earh
    y: y-coordinate  normalized to the radius of Earh
    z: z-coordinate  normalized to the radius of Earh
    """

    alt = -1.0 * 1000.0 * depth  # height above WGS84 ellipsoid (m)
    lat = np.deg2rad(lat)
    cos_lat = np.cos(lat)
    sin_lat = np.sin(lat)

    # World Geodetic System 1984, WGS 84
    erad = np.float64(6378137.0)  # Radius of the Earth in meters (equatorial radius, WGS84)
    rad = 1  # sphere radius
    e = np.float64(8.1819190842622e-2)
    n = erad / np.sqrt(1.0 - e * e * sin_lat * sin_lat)  # prime vertical radius of curvature

    lon = np.deg2rad(lon)
    cos_lon = np.cos(lon)
    sin_lon = np.sin(lon)

    x = (n + alt) * cos_lat * cos_lon  # meters
    y = (n + alt) * cos_lat * sin_lon  # meters
    z = ((1 - e * e) * n + alt) * sin_lat  # meters

    x = x * rad / erad  # normalize to radius of rad
    y = y * rad / erad  # normalize to radius of rad
    z = z * rad / erad  # normalize to radius of rad
    return x, y, z
    
print(">>>>>>")    
startLat = 50
startLon = -123
endLat =  40.5
endLon = -108
n = 100000
x = xr.DataArray(np.linspace(startLon,endLon,n), dims='along_course')
y = xr.DataArray(np.linspace(startLat,endLat,n), dims='along_course')
# Assigne the desired variable.
VARIABLE = 'dvs'
    
# matplotlib colormap to use. For available colormaps see:
# https://matplotlib.org/stable/tutorials/colors/colormaps.html
COLORMAP ='jet_r'
dsv = utils.get_dsv(ds, VARIABLE)
levels = np.linspace(-3, 3, num=50)
xsection = dsv.interp(longitude=x, latitude=y, method='nearest')
xsection.plot( y="depth", cmap=COLORMAP, levels=levels)
plt.gca().invert_yaxis()
plt.show()
